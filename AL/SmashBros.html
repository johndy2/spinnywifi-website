<!DOCTYPE html>
<html>
<head>
    <title>Shadow Brawler - Story Mode</title>
    <style>
        body { background: #222; display: flex; flex-direction: column; align-items: center; color: white; font-family: sans-serif; }
        canvas { background: #333; border: 4px solid #555; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        #ui { position: absolute; top: 20px; width: 800px; display: flex; justify-content: space-between; font-size: 24px; pointer-events: none; }
        #story { margin-top: 10px; width: 780px; background: rgba(0,0,0,0.8); padding: 10px; border-left: 5px solid #00f; }
    </style>
</head>
<body>
    <div id="ui">
        <div id="p1">Hero: 0%</div>
        <div id="p2">Shadow: 0%</div>
    </div>
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    <div id="story"><b>CHAPTER 1:</b> "The mirror world has fractured. Defeat your shadow to escape the void." (Move: Arrows | Attack: Space)</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const GRAVITY = 0.5;
const FRICTION = 0.8;

class Fighter {
    constructor(x, color, isPlayer) {
        this.x = x; this.y = 200; this.w = 40; this.h = 60;
        this.color = color; this.isPlayer = isPlayer;
        this.vx = 0; this.vy = 0;
        this.damage = 0; this.isJumping = false;
        this.facing = 1; // 1 for right, -1 for left
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        // Draw eyes to show direction
        ctx.fillStyle = "white";
        ctx.fillRect(this.x + (this.facing == 1 ? 25 : 5), this.y + 10, 10, 10);
    }

    update() {
        this.vy += GRAVITY;
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= FRICTION;

        // Platform collision (Simple floor at 350)
        if (this.y + this.h > 350) {
            this.y = 350 - this.h;
            this.vy = 0;
            this.isJumping = false;
        }

        // Screen boundaries
        if (this.x < 0) this.x = 0;
        if (this.x > canvas.width - this.w) this.x = canvas.width - this.w;
    }

    attack(target) {
        let hitrange = this.facing == 1 ? this.x + this.w + 20 : this.x - 20;
        if (Math.abs(hitrange - target.x) < 40 && Math.abs(this.y - target.y) < 60) {
            target.damage += 10;
            // SMASH PHYSICS: Knockback increases with damage
            let knockback = (target.damage / 10) * 2;
            target.vx = this.facing * knockback;
            target.vy = -knockback / 2;
        }
    }
}

const p1 = new Fighter(100, '#00f', true);
const p2 = new Fighter(600, '#f00', false);
const keys = {};

window.addEventListener('keydown', e => { keys[e.code] = true; if(e.code === 'Space') p1.attack(p2); });
window.addEventListener('keyup', e => keys[e.code] = false);

function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw Floor
    ctx.fillStyle = "#555";
    ctx.fillRect(0, 350, canvas.width, 50);

    // Player Movement
    if (keys['ArrowLeft']) { p1.vx = -5; p1.facing = -1; }
    if (keys['ArrowRight']) { p1.vx = 5; p1.facing = 1; }
    if (keys['ArrowUp'] && !p1.isJumping) { p1.vy = -12; p1.isJumping = true; }

    // Simple AI
    if (p2.x > p1.x + 50) { p2.vx = -2; p2.facing = -1; }
    else if (p2.x < p1.x - 50) { p2.vx = 2; p2.facing = 1; }
    if (Math.random() > 0.98) p2.attack(p1);

    p1.update(); p2.update();
    p1.draw(); p2.draw();

    document.getElementById('p1').innerText = `Hero: ${p1.damage}%`;
    document.getElementById('p2').innerText = `Shadow: ${p2.damage}%`;

    requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
