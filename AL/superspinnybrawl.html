<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Drive Smash - Time Attack (Bot Edition)</title>
    <style>
        body { background: #0a0a0c; color: #00ffcc; text-align: center; font-family: 'Courier New', monospace; overflow: hidden; margin: 0; }
        canvas { background: #050505; border: 2px solid #00ffcc; display: block; margin: 10px auto; box-shadow: 0 0 30px #004433; }
        .hud { display: flex; justify-content: center; align-items: center; gap: 50px; font-size: 35px; margin-top: 20px; text-shadow: 0 0 10px #00ffcc; }
        .timer { font-size: 50px; color: #fff; border: 2px solid #fff; padding: 5px 20px; min-width: 100px; }
        .p1 { color: #00d2ff; } .p2 { color: #ff0055; }
        .win-msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 40px; background: rgba(0,0,0,0.9); padding: 40px; display: none; border: 2px solid #00ffcc; z-index: 10; }
    </style>
</head>
<body>
    <div id="winMsg" class="win-msg">TIME UP!</div>
    <div class="hud">
        <div class="p1">C: <span id="p1%">0</span>%</div>
        <div id="timer" class="timer">60</div>
        <div class="p2">BOT: <span id="p2%">0</span>%</div>
    </div>
    <canvas id="game" width="900" height="500"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let particles = [];
let gameRunning = true;
let platterRotation = 0;
let timeLeft = 60;

// Timer Countdown
const timerInterval = setInterval(() => {
    if (gameRunning) {
        timeLeft--;
        document.getElementById("timer").innerText = timeLeft;
        if (timeLeft <= 0) {
            const winner = p1.percent < p2.percent ? "DRIVE C: WINS" : "BOT WINS";
            endGame(winner);
        }
    }
}, 1000);

class Fighter {
    constructor(x, color, controls, name, label, isBot = false) {
        this.startX = x; this.x = x; this.y = 200; this.w = 45; this.h = 60;
        this.color = color; this.controls = controls; this.name = name; this.label = label;
        this.vx = 0; this.vy = 0; this.percent = 0; this.isBot = isBot;
        this.isGrounded = false; this.jumpCount = 0; this.maxJumps = 2; this.dir = 1; this.canJump = true;
        this.attackCooldown = 0;
    }

    update(keys, opponent) {
        if (!gameRunning) return;

        if (this.isBot) {
            this.handleAI(opponent);
        } else {
            if (keys[this.controls.left]) { this.vx = -5.5; this.dir = -1; }
            else if (keys[this.controls.right]) { this.vx = 5.5; this.dir = 1; }
            else { this.vx *= 0.88; }

            if (keys[this.controls.up]) {
                if (this.canJump && this.jumpCount < this.maxJumps) {
                    this.vy = -13; this.jumpCount++; this.isGrounded = false; this.canJump = false;
                }
            } else { this.canJump = true; }

            if (keys[this.controls.attack]) {
                this.performAttack(opponent);
                keys[this.controls.attack] = false; 
            }
        }

        this.vy += 0.55; this.x += this.vx; this.y += this.vy;

        // Platform Collision
        if (this.x + this.w > 200 && this.x < 700 && this.y + this.h > 400 && this.y < 420 && this.vy >= 0) {
            this.y = 400 - this.h; this.vy = 0; this.isGrounded = true; this.jumpCount = 0;
        } else { this.isGrounded = false; }

        if (this.x < -100 || this.x > canvas.width + 100 || this.y < -100 || this.y > canvas.height + 100) this.respawn();
    }

    handleAI(target) {
        // Recovery Logic
        if (this.x < 200) { this.vx = 4; if(this.jumpCount < 2) { this.vy = -12; this.jumpCount++; } }
        else if (this.x > 650) { this.vx = -4; if(this.jumpCount < 2) { this.vy = -12; this.jumpCount++; } }
        else {
            // Chase logic
            if (target.x < this.x - 40) { this.vx = -4; this.dir = -1; }
            else if (target.x > this.x + 40) { this.vx = 4; this.dir = 1; }
            else { this.vx *= 0.8; }
        }

        // Attack logic
        this.attackCooldown--;
        let dist = Math.abs(target.x - this.x);
        if (dist < 60 && Math.abs(target.y - this.y) < 30 && this.attackCooldown <= 0) {
            this.performAttack(target);
            this.attackCooldown = 30;
        }
    }

    performAttack(opponent) {
        let hitX = this.x + (this.dir === 1 ? 40 : -40);
        if (hitX < opponent.x + opponent.w && hitX + 30 > opponent.x && this.y < opponent.y + opponent.h && this.y + this.h > opponent.y) {
            opponent.takeHit(this.dir);
        }
    }

    takeHit(direction) {
        this.percent += 12;
        let kb = 5 + (this.percent * 0.22);
        this.vx = direction * kb; this.vy = -kb * 0.35;
        document.getElementById(this.name + "%").innerText = this.percent;
        for(let i=0; i<8; i++) particles.push({x: this.x+22, y: this.y+30, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, alpha: 1, color: this.color, text: Math.round(Math.random())});
    }

    respawn() {
        for (let i = 0; i < 40; i++) particles.push({x: this.x+22, y: this.y+30, vx: (Math.random()-0.5)*20, vy: (Math.random()-0.5)*20, alpha: 1, color: "#fff", text: "ERR"});
        this.percent += 20; // Penalty for falling
        this.x = 450; this.y = 100; this.vx = 0; this.vy = 0; 
        document.getElementById(this.name + "%").innerText = this.percent;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.fillStyle = "#333"; ctx.strokeStyle = "#888"; ctx.lineWidth = 2;
        ctx.fillRect(0, 0, this.w, this.h);
        ctx.strokeRect(0, 0, this.w, this.h);
        ctx.beginPath(); ctx.arc(this.w/2, this.h/1.6, 18, 0, Math.PI*2);
        ctx.fillStyle = "#111"; ctx.fill(); ctx.strokeStyle = this.color; ctx.stroke();
        ctx.beginPath(); ctx.arc(this.w/2, this.h/1.6, 15, platterRotation, platterRotation + 1);
        ctx.strokeStyle = "rgba(255,255,255,0.3)"; ctx.lineWidth = 3; ctx.stroke();
        ctx.fillStyle = "white"; ctx.font = "bold 10px Courier";
        ctx.fillText(this.label, 5, 15);
        ctx.restore();
    }
}

function endGame(winner) {
    gameRunning = false;
    clearInterval(timerInterval);
    const msg = document.getElementById("winMsg");
    msg.innerHTML = "TIME UP!<br>" + winner;
    msg.style.display = "block";
    setTimeout(() => location.reload(), 5000);
}

const p1 = new Fighter(300, "#00d2ff", {up:'w', left:'a', right:'d', attack:' '}, "p1", "C:");
const p2 = new Fighter(600, "#ff0055", null, "p2", "BOT", true);

const keys = {};
window.onkeydown = (e) => { if(["Space","ArrowUp"].includes(e.code)) e.preventDefault(); keys[e.key] = true; };
window.onkeyup = (e) => keys[e.key] = false;

function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    platterRotation += 0.2;
    ctx.fillStyle = "#002211"; ctx.fillRect(200, 400, 500, 15);
    ctx.strokeStyle = "#00ffcc"; ctx.strokeRect(200, 400, 500, 15);
    p1.update(keys, p2); p2.update(keys, p1);
    p1.draw(); p2.draw();
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i]; p.x += p.vx; p.y += p.vy; p.alpha -= 0.02;
        ctx.globalAlpha = p.alpha; ctx.fillStyle = p.color; ctx.font = "12px Courier";
        ctx.fillText(p.text, p.x, p.y);
        if (p.alpha <= 0) particles.splice(i, 1);
    }
    ctx.globalAlpha = 1;
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
